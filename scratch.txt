stack.getProtocol(IpProtocol.class)
    .enableTunnelDecapsulation(true)  // GRE, VXLAN, etc.
    .maxTunnelDepth(3);
    
    stack.getProtocol(IpProtocol.class)
    .enableReassembly(new IpReassemblySettings()
        .preserveFragments(true));  // Emit originals too?
        
        
┌─────────────────────────────────────────────────────────────────────────────┐
│                    DESCRIPTORS AS THE ANSWER                                 │
│                                                                              │
│   Not tokens for SDK users. Descriptors.                                    │
│   User chooses descriptor type based on detail needed.                      │
│   All metadata encoded there.                                               │
└─────────────────────────────────────────────────────────────────────────────┘

   Packet + Descriptor = Complete Information
   
   ┌─────────────────────────────────────────────────────────────────────────┐
   │  Packet Memory                                                          │
   │  [Ethernet][IP][TCP][HTTP payload...]                                   │
   └─────────────────────────────────────────────────────────────────────────┘
                            │
                            │ described by
                            ▼
   ┌─────────────────────────────────────────────────────────────────────────┐
   │  Descriptor                                                             │
   │                                                                         │
   │  Header table:                                                          │
   │    [0] Eth    offset=0   len=14   id=ETHERNET                          │
   │    [1] IP     offset=14  len=20   id=IP4                               │
   │    [2] TCP    offset=34  len=20   id=TCP    flags=REASSEMBLED          │
   │    [3] HTTP   offset=54  len=245  id=HTTP   flags=DECRYPTED            │
   │                                                                         │
   │  Metadata:                                                              │
   │    reassemblyStatus: COMPLETE                                           │
   │    decryptionStatus: SUCCESS                                            │
   │    originalPacketIndex: 1000                                            │
   │    fragmentCount: 3                                                     │
   │    ...                                                                  │
   └─────────────────────────────────────────────────────────────────────────┘
   
Net1PacketDescriptor (minimal)
   ══════════════════════════════
   • Timestamp, length, wire length
   • Basic capture info
   • For: High-speed capture, minimal overhead
   
   
   Net2PacketDescriptor (standard)
   ═══════════════════════════════
   • Header table (offset/length/id)
   • hasHeader() support
   • For: Protocol-aware processing
   
   
   Net3PacketDescriptor (rich)
   ════════════════════════════
   • Full header table
   • Processing flags per header
   • Reassembly metadata
   • Decryption status
   • Flow correlation
   • For: Analysis, troubleshooting
   
   
   User chooses:
   ═════════════
   
   PacketStream[] streams = networks.createRxStreams("rx-%d", 4, stack,
       Net3PacketDescriptor.class);  // I want full metadata
       
       
       
IP FRAGMENTS:
   ═════════════
   
   Fragment 1 arrives → pass through (descriptor: FRAGMENT, offset=0)
   Fragment 2 arrives → pass through (descriptor: FRAGMENT, offset=1480)
   Fragment 3 arrives → pass through (descriptor: FRAGMENT, offset=2960, LAST)
                      → emit reassembled packet (descriptor: REASSEMBLED, fragCount=3)
   
   User sees 4 packets total if preserveFragments(true)
   User sees 1 packet if preserveFragments(false)


   ENCRYPTED (no key):
   ═══════════════════
   
   Encrypted packet → pass through (descriptor: ENCRYPTED, decryptStatus=NO_KEY)
   
   User checks: packet.hasHeader(tcp) → false (still encrypted)
   User checks: descriptor.decryptionStatus() → NO_KEY
   User knows why.


   TCP REASSEMBLY:
   ════════════════
   
   Seg 1 (seq=0)    → emit immediately (descriptor: IN_ORDER)
   Seg 3 (seq=2000) → buffer (hole at 1000)
   Seg 2 (seq=1000) → emit seg 2 + seg 3 (descriptor: REORDERED)
   Timeout          → emit buffered with (descriptor: INCOMPLETE, reason=TIMEOUT)


   TUNNEL DECAP:
   ══════════════
   
   [Eth][VLAN][IP][GRE][Inner-IP][TCP][HTTP]
                    │
                    │ decap
                    ▼
   [Eth][Inner-IP][TCP][HTTP]
   
   Descriptor: tunnelDepth=2, originalEncap=[VLAN, GRE]
   
   
   
   
   
// Per-header flags in descriptor

public interface HeaderFlags {
    int NONE          = 0;
    int REASSEMBLED   = 1 << 0;  // From fragments or segments
    int DECRYPTED     = 1 << 1;  // Was encrypted
    int DECOMPRESSED  = 1 << 2;  // Was compressed
    int DECAPSULATED  = 1 << 3;  // Tunnel removed
    int OUT_OF_ORDER  = 1 << 4;  // Arrived OOO
    int INCOMPLETE    = 1 << 5;  // Missing data
    int TRUNCATED     = 1 << 6;  // Data truncated
}

// Packet-level metadata in descriptor

public interface PacketStatus {
    int ORIGINAL           = 0;  // Unmodified
    int REASSEMBLED_IP     = 1 << 0;
    int REASSEMBLED_TCP    = 1 << 1;
    int DECRYPTED_IPSEC    = 1 << 2;
    int DECRYPTED_TLS      = 1 << 3;
    int DECAPSULATED       = 1 << 4;
    int FRAGMENT           = 1 << 5;  // This is a fragment, not reassembled
    int ENCRYPTED          = 1 << 6;  // Still encrypted (no key)
}


try (NetWorks networks = new DpdkWorks()) {

    ProtocolStack stack = new ProtocolStack();
    
    // IP configuration
    stack.getProtocol(IpProtocol.class)
        .enableReassembly(new IpReassemblySettings()
            .timeout(5, TimeUnit.SECONDS)
            .preserveFragments(true))
        .enableIpsecDecryption(new IpsecSettings()
            .keyStore(keyStore)
            .skipOnNoKey(true));  // Don't block, pass through
    
    // TCP configuration  
    stack.getProtocol(TcpProtocol.class)
        .enableReassembly(new TcpReassemblySettings()
            .maxOutOfOrder(200)
            .timeout(30, TimeUnit.SECONDS)
            .emitPartialOnTimeout(true));
    
    // TLS configuration
    stack.getProtocol(TlsProtocol.class)
        .enableDecryption(new TlsSettings()
            .keyStore(tlsKeyStore));
    
    // Tunnel/VLAN decapsulation
    stack.getProtocol(VlanProtocol.class)
        .enableDecapsulation(true);
    
    stack.getProtocol(GreProtocol.class)
        .enableDecapsulation(new GreSettings()
            .maxDepth(3));

    // Create streams with rich descriptors
    PacketStream[] streams = networks.createRxStreams("rx-%d", 4, 
        stack, 
        Net3PacketDescriptor.class);

    // Process
    scope.fork(stream, s -> {
        Ip4 ip = new Ip4();
        Tcp tcp = new Tcp();
        
        while (s.isActive()) {
            Packet packet = s.take();
            Net3PacketDescriptor desc = packet.descriptor();
            
            // Check what happened to this packet
            if (desc.isReassembled()) {
                System.out.println("Reassembled from " + desc.fragmentCount() + " fragments");
            }
            
            if (desc.isDecrypted()) {
                System.out.println("Decrypted with " + desc.cipherSuite());
            }
            
            if (desc.isEncrypted()) {
                System.out.println("Still encrypted - no key for SPI " + desc.spi());
            }
            
            if (desc.isIncomplete()) {
                System.out.println("Incomplete: " + desc.incompleteReason());
            }
            
            // Normal header access - works regardless of processing
            if (packet.hasHeader(ip)) {
                if (packet.hasHeader(tcp)) {
                    // Process TCP payload
                    // Might be reassembled stream, might be single segment
                    // User doesn't care
                    processPayload(tcp.payload());
                }
            }
            
            s.release(packet);
        }
    });
}



try (Capture capture = new DpdkBackend()) {
    PacketStream[] streams = capture.createRxStreams("rx-%d", 4, stack);
    capture.filter("tcp.port == 443").assignTo(streams).apply();
}

try (Net net = new DpdkBackend()) {
    PacketStream[] streams = net.createRxStreams("rx-%d", 4, stack);
    net.filter("tcp.port == 443").assignTo(streams).apply();
}

while (stream.isActive()) {
    Packet packet = stream.take();
    
    // Process, maybe modify
    if (shouldForward(packet)) {
        packet.setTransmit(true);
        packet.setTransmitPort("en1");
    }
    
    stream.release(packet);  // Frees OR transmits based on flags
}















